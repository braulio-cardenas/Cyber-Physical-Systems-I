<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Color/Grayscale + Resolution & Bit-Depth Playground</title>
  <style>
    /* ... (same CSS as before) ... */
  </style>
</head>
<body>
  <header>
    <h1>Color ↔ Grayscale · Resolution · Bit Depth</h1>
    <p>Upload an image, then tweak color mode, simulated resolution (downscale/nearest-neighbor upscale), and bit depth. Everything runs locally in your browser.</p>
  </header>

  <div class="wrap">
    <div class="controls panel">
      <div class="group">
        <h2>1) Image</h2>
        <div class="filebox">
          <input id="file" type="file" accept="image/*" />
          <button id="loadSample" title="Load a built-in sample" class="ghost">Load sample</button>
        </div>
        <p class="hint">Tip: very large images are handled fine; preview is scaled to fit. Processing always uses the full resolution internally.</p>
      </div>

      <div class="group">
        <h2>2) Adjustments</h2>

        <div class="row">
          <label>Color mode</label>
          <div>
            <div class="seg" role="tablist" aria-label="Color mode">
              <input type="radio" id="modeColor" name="mode" value="color" checked />
              <label for="modeColor">Color</label>
              <input type="radio" id="modeGray" name="mode" value="gray" />
              <label for="modeGray">Grayscale</label>
            </div>
          </div>
          <div></div>
        </div>

        <div class="row">
          <label for="res">Resolution (% of original)</label>
          <input id="res" type="range" min="1" max="100" step="1" value="100" />
          <div id="resVal">100%</div>
        </div>

        <div class="row">
          <label for="bits">Bit depth (per channel)</label>
          <input id="bits" type="range" min="1" max="8" step="1" value="8" />
          <div id="bitsVal">8-bit</div>
        </div>

        <div class="btns">
          <button id="reset">Reset</button>
          <!-- Removed download button -->
        </div>
      </div>
    </div>

    <div class="canvases">
      <div class="canvas-card">
        <div class="canvas-head">
          <h3>Original</h3>
          <div class="dim" id="origDim">–</div>
        </div>
        <canvas id="orig"></canvas>
      </div>
      <div class="canvas-card">
        <div class="canvas-head">
          <h3>Processed</h3>
          <div class="dim" id="procDim">–</div>
        </div>
        <canvas id="proc"></canvas>
        <div class="hint">Nearest-neighbor upscaling is used to make reduced resolution visible (pixelation). Bit-depth reduction quantizes values to <span id="levelsLabel">256</span> levels.</div>
      </div>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('file');
    const loadSampleBtn = document.getElementById('loadSample');
    const res = document.getElementById('res');
    const resVal = document.getElementById('resVal');
    const bits = document.getElementById('bits');
    const bitsVal = document.getElementById('bitsVal');
    const levelsLabel = document.getElementById('levelsLabel');
    const modeColor = document.getElementById('modeColor');
    const modeGray = document.getElementById('modeGray');

    const origCanvas = document.getElementById('orig');
    const procCanvas = document.getElementById('proc');
    const octx = origCanvas.getContext('2d');
    const pctx = procCanvas.getContext('2d');

    const origDim = document.getElementById('origDim');
    const procDim = document.getElementById('procDim');

    const resetBtn = document.getElementById('reset');

    let originalImage = new Image();
    originalImage.onload = () => {
      setCanvasesToImage(originalImage);
      render();
    };

    function setCanvasesToImage(img) {
      const w = img.naturalWidth || img.width;
      const h = img.naturalHeight || img.height;
      origCanvas.width = w; origCanvas.height = h;
      procCanvas.width = w; procCanvas.height = h;
      octx.clearRect(0,0,w,h);
      octx.drawImage(img, 0, 0, w, h);
      origDim.textContent = `${w} × ${h}px`;
      procDim.textContent = `${w} × ${h}px`;
    }

    function quantizeChannel(value, bits) {
      const levels = 1 << bits;
      if (levels <= 1) return 0;
      const q = Math.round((value / 255) * (levels - 1));
      return Math.round((q * 255) / (levels - 1));
    }

    function render() {
      if (!origCanvas.width || !origCanvas.height) return;
      const w = origCanvas.width, h = origCanvas.height;
      const scalePct = parseInt(res.value, 10);
      const b = parseInt(bits.value, 10);
      const colorMode = modeGray.checked ? 'gray' : 'color';

      resVal.textContent = `${scalePct}%`;
      bitsVal.textContent = `${b}\u2011bit`;
      const levels = 1 << b;
      levelsLabel.textContent = levels.toString();

      const workW = Math.max(1, Math.round(w * scalePct / 100));
      const workH = Math.max(1, Math.round(h * scalePct / 100));
      const work = document.createElement('canvas');
      work.width = workW; work.height = workH;
      const wctx = work.getContext('2d');
      wctx.imageSmoothingEnabled = true;
      wctx.imageSmoothingQuality = 'high';
      wctx.drawImage(origCanvas, 0, 0, w, h, 0, 0, workW, workH);

      let imgData = wctx.getImageData(0, 0, workW, workH);
      let data = imgData.data;
      for (let i = 0; i < data.length; i += 4) {
        let r = data[i], g = data[i+1], bch = data[i+2];
        if (colorMode === 'gray') {
          const y = 0.299 * r + 0.587 * g + 0.114 * bch;
          const q = quantizeChannel(y, b);
          data[i] = data[i+1] = data[i+2] = q;
        } else {
          data[i]   = quantizeChannel(r, b);
          data[i+1] = quantizeChannel(g, b);
          data[i+2] = quantizeChannel(bch, b);
        }
      }
      wctx.putImageData(imgData, 0, 0);

      pctx.save();
      pctx.clearRect(0, 0, w, h);
      pctx.imageSmoothingEnabled = false;
      pctx.drawImage(work, 0, 0, workW, workH, 0, 0, w, h);
      pctx.restore();
      procDim.textContent = `${w} × ${h}px (source @ ${workW}×${workH})`;
    }

    function resetUI() {
      res.value = 100; bits.value = 8; modeColor.checked = true; modeGray.checked = false;
      render();
    }

    [res, bits, modeColor, modeGray].forEach(el => el.addEventListener('input', render));
    resetBtn.addEventListener('click', resetUI);

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => { originalImage.src = ev.target.result; };
      reader.readAsDataURL(file);
    });

    loadSampleBtn.addEventListener('click', () => {
      const svg = encodeURIComponent(`
        <svg xmlns='http://www.w3.org/2000/svg' width='1200' height='800'>
          <defs>
            <linearGradient id='g1' x1='0' y1='0' x2='1' y2='1'>
              <stop offset='0%' stop-color='#ff6b6b'/>
              <stop offset='50%' stop-color='#ffd93d'/>
              <stop offset='100%' stop-color='#6bcBff'/>
            </linearGradient>
            <linearGradient id='g2' x1='1' y1='0' x2='0' y2='1'>
              <stop offset='0%' stop-color='#9b5de5'/>
              <stop offset='50%' stop-color='#00f5d4'/>
              <stop offset='100%' stop-color='#fee440'/>
            </linearGradient>
            <pattern id='p' width='200' height='200' patternUnits='userSpaceOnUse'>
              <rect width='200' height='200' fill='url(#g1)'/>
              <circle cx='100' cy='100' r='70' fill='url(#g2)' opacity='0.8'/>
            </pattern>
          </defs>
          <rect width='1200' height='800' fill='url(#p)'/>
        </svg>`);
      originalImage.src = `data:image/svg+xml;charset=utf-8,${svg}`;
    });

    (function initBlank() {
      const blank = document.createElement('canvas');
      blank.width = 640; blank.height = 400;
      const ctx = blank.getContext('2d');
      const grd = ctx.createLinearGradient(0,0,640,0);
      grd.addColorStop(0,'#1a2a3a'); grd.addColorStop(1,'#0e1720');
      ctx.fillStyle = grd; ctx.fillRect(0,0,640,400);
      ctx.fillStyle = 'rgba(255,255,255,0.06)';
      for(let y=20; y<400; y+=20){ for(let x=20; x<640; x+=20){ ctx.fillRect(x, y, 2, 2); } }
      originalImage.src = blank.toDataURL('image/png');
    })();
  </script>
</body>
</html>
